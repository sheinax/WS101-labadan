import { inspect } from 'node:util';
import { parseArgs } from './parse-args.js';
// it's a tiny API, just cast it inline, it's fine
//@ts-ignore
import cliui from '@isaacs/cliui';
import { basename } from 'node:path';
const width = Math.min((process && process.stdout && process.stdout.columns) || 80, 80);
// indentation spaces from heading level
const indent = (n) => (n - 1) * 2;
const toEnvKey = (pref, key) => {
    return [pref, key.replace(/[^a-zA-Z0-9]+/g, ' ')]
        .join(' ')
        .trim()
        .toUpperCase()
        .replace(/ /g, '_');
};
const toEnvVal = (value, delim = '\n') => {
    const str = typeof value === 'string'
        ? value
        : typeof value === 'boolean'
            ? value
                ? '1'
                : '0'
            : typeof value === 'number'
                ? String(value)
                : Array.isArray(value)
                    ? value
                        .map((v) => toEnvVal(v))
                        .join(delim)
                    : /* c8 ignore start */
                        undefined;
    if (typeof str !== 'string') {
        throw new Error(`could not serialize value to environment: ${JSON.stringify(value)}`);
    }
    /* c8 ignore stop */
    return str;
};
const fromEnvVal = (env, type, multiple, delim = '\n') => (multiple
    ? env
        ? env.split(delim).map(v => fromEnvVal(v, type, false))
        : []
    : type === 'string'
        ? env
        : type === 'boolean'
            ? env === '1'
            : +env.trim());
export const isConfigType = (t) => typeof t === 'string' &&
    (t === 'string' || t === 'number' || t === 'boolean');
const undefOrType = (v, t) => v === undefined || typeof v === t;
// print the value type, for error message reporting
const valueType = (v) => typeof v === 'string'
    ? 'string'
    : typeof v === 'boolean'
        ? 'boolean'
        : typeof v === 'number'
            ? 'number'
            : Array.isArray(v)
                ? joinTypes([...new Set(v.map(v => valueType(v)))]) + '[]'
                : `${v.type}${v.multiple ? '[]' : ''}`;
const joinTypes = (types) => types.length === 1 && typeof types[0] === 'string'
    ? types[0]
    : `(${types.join('|')})`;
const isValidValue = (v, type, multi) => {
    if (multi) {
        if (!Array.isArray(v))
            return false;
        return !v.some((v) => !isValidValue(v, type, false));
    }
    if (Array.isArray(v))
        return false;
    return typeof v === type;
};
export const isConfigOption = (o, type, multi) => !!o &&
    typeof o === 'object' &&
    isConfigType(o.type) &&
    o.type === type &&
    undefOrType(o.short, 'string') &&
    undefOrType(o.description, 'string') &&
    undefOrType(o.hint, 'string') &&
    undefOrType(o.validate, 'function') &&
    (o.default === undefined || isValidValue(o.default, type, multi)) &&
    !!o.multiple === multi;
function num(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: false,
    };
}
function numList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: true,
    };
}
function opt(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: false,
    };
}
function optList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: true,
    };
}
function flag(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: false,
    };
}
function flagList(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag list');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: true,
    };
}
const toParseArgsOptionsConfig = (options) => {
    const c = {};
    for (const longOption in options) {
        const config = options[longOption];
        /* c8 ignore start */
        if (!config) {
            throw new Error('config must be an object: ' + longOption);
        }
        /* c8 ignore start */
        if (isConfigOption(config, 'number', true)) {
            c[longOption] = {
                type: 'string',
                multiple: true,
                default: config.default?.map(c => String(c)),
            };
        }
        else if (isConfigOption(config, 'number', false)) {
            c[longOption] = {
                type: 'string',
                multiple: false,
                default: config.default === undefined
                    ? undefined
                    : String(config.default),
            };
        }
        else {
            const conf = config;
            c[longOption] = {
                type: conf.type,
                multiple: conf.multiple,
                default: conf.default,
            };
        }
        const clo = c[longOption];
        if (typeof config.short === 'string') {
            clo.short = config.short;
        }
        if (config.type === 'boolean' &&
            !longOption.startsWith('no-') &&
            !options[`no-${longOption}`]) {
            c[`no-${longOption}`] = {
                type: 'boolean',
                multiple: config.multiple,
            };
        }
    }
    return c;
};
const isHeading = (r) => r.type === 'heading';
const isDescription = (r) => r.type === 'description';
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
export class Jack {
    #configSet;
    #shorts;
    #options;
    #fields = [];
    #env;
    #envPrefix;
    #allowPositionals;
    #usage;
    #usageMarkdown;
    constructor(options = {}) {
        this.#options = options;
        this.#allowPositionals = options.allowPositionals !== false;
        this.#env =
            this.#options.env === undefined ? process.env : this.#options.env;
        this.#envPrefix = options.envPrefix;
        // We need to fib a little, because it's always the same object, but it
        // starts out as having an empty config set.  Then each method that adds
        // fields returns `this as Jack<C & { ...newConfigs }>`
        this.#configSet = Object.create(null);
        this.#shorts = Object.create(null);
    }
    /**
     * Set the default value (which will still be overridden by env or cli)
     * as if from a parsed config file. The optional `source` param, if
     * provided, will be included in error messages if a value is invalid or
     * unknown.
     */
    setConfigValues(values, source = '') {
        try {
            this.validate(values);
        }
        catch (er) {
            throw Object.assign(er, source ? { source } : {});
        }
        for (const [field, value] of Object.entries(values)) {
            const my = this.#configSet[field];
            // already validated, just for TS's benefit
            /* c8 ignore start */
            if (!my) {
                throw new Error('unexpected field in config set: ' + field);
            }
            /* c8 ignore stop */
            my.default = value;
        }
        return this;
    }
    /**
     * Parse a string of arguments, and return the resulting
     * `{ values, positionals }` object.
     *
     * If an {@link JackOptions#envPrefix} is set, then it will read default
     * values from the environment, and write the resulting values back
     * to the environment as well.
     *
     * Environment values always take precedence over any other value, except
     * an explicit CLI setting.
     */
    parse(args = process.argv) {
        if (args === process.argv) {
            args = args.slice(process._eval !== undefined ? 1 : 2);
        }
        if (this.#envPrefix) {
            for (const [field, my] of Object.entries(this.#configSet)) {
                const ek = toEnvKey(this.#envPrefix, field);
                const env = this.#env[ek];
                if (env !== undefined) {
                    my.default = fromEnvVal(env, my.type, !!my.multiple, my.delim);
                }
            }
        }
        const options = toParseArgsOptionsConfig(this.#configSet);
        const result = parseArgs({
            args,
            options,
            // always strict, but using our own logic
            strict: false,
            allowPositionals: this.#allowPositionals,
            tokens: true,
        });
        const p = {
            values: {},
            positionals: [],
        };
        for (const token of result.tokens) {
            if (token.kind === 'positional') {
                p.positionals.push(token.value);
                if (this.#options.stopAtPositional) {
                    p.positionals.push(...args.slice(token.index + 1));
                    return p;
                }
            }
            else if (token.kind === 'option') {
                let value = undefined;
                if (token.name.startsWith('no-')) {
                    const my = this.#configSet[token.name];
                    const pname = token.name.substring('no-'.length);
                    const pos = this.#configSet[pname];
                    if (pos &&
                        pos.type === 'boolean' &&
                        (!my ||
                            (my.type === 'boolean' && !!my.multiple === !!pos.multiple))) {
                        value = false;
                        token.name = pname;
                    }
                }
                const my = this.#configSet[token.name];
                if (!my) {
                    throw new Error(`Unknown option '${token.rawName}'. ` +
                        `To specify a positional argument starting with a '-', ` +
                        `place it at the end of the command after '--', as in ` +
                        `'-- ${token.rawName}'`);
                }
                if (value === undefined) {
                    if (token.value === undefined) {
                        if (my.type !== 'boolean') {
                            throw new Error(`No value provided for ${token.rawName}, expected ${my.type}`);
                        }
                        value = true;
                    }
                    else {
                        if (my.type === 'boolean') {
                            throw new Error(`Flag ${token.rawName} does not take a value, received '${token.value}'`);
                        }
                        if (my.type === 'string') {
                            value = token.value;
                        }
                        else {
                            value = +token.value;
                            if (value !== value) {
                                throw new Error(`Invalid value '${token.value}' provided for ` +
                                    `'${token.rawName}' option, expected number`);
                            }
                        }
                    }
                }
                if (my.multiple) {
                    const pv = p.values;
                    const tn = pv[token.name] ?? [];
                    pv[token.name] = tn;
                    tn.push(value);
                }
                else {
                    const pv = p.values;
                    pv[token.name] = value;
                }
            }
        }
        for (const [field, c] of Object.entries(this.#configSet)) {
            if (c.default !== undefined && !(field in p.values)) {
                //@ts-ignore
                p.values[field] = c.default;
            }
        }
        for (const [field, value] of Object.entries(p.values)) {
            const valid = this.#configSet[field]?.validate;
            if (valid && !valid(value)) {
                throw new Error(`Invalid value provided for --${field}: ${JSON.stringify(value)}`);
            }
        }
        this.#writeEnv(p);
        return p;
    }
    /**
     * do not set fields as 'no-foo' if 'foo' exists and both are bools
     * just set foo.
     */
    #noNoFields(f, val, s = f) {
        if (!f.startsWith('no-') || typeof val !== 'boolean')
            return;
        const yes = f.substring('no-'.length);
        // recurse so we get the core config key we care about.
        this.#noNoFields(yes, val, s);
        if (this.#configSet[yes]?.type === 'boolean') {
            throw new Error(`do not set '${s}', instead set '${yes}' as desired.`);
        }
    }
    /**
     * Validate that any arbitrary object is a valid configuration `values`
     * object.  Useful when loading config files or other sources.
     */
    validate(o) {
        if (!o || typeof o !== 'object') {
            throw new Error('Invalid config: not an object');
        }
        for (const field in o) {
            this.#noNoFields(field, o[field]);
            const config = this.#configSet[field];
            if (!config) {
                throw new Error(`Unknown config option: ${field}`);
            }
            if (!isValidValue(o[field], config.type, !!config.multiple)) {
                throw Object.assign(new Error(`Invalid value ${valueType(o[field])} for ${field}, expected ${valueType(config)}`), {
                    field,
                    value: o[field],
                });
            }
            if (config.validate && !config.validate(o[field])) {
                throw new Error(`Invalid config value for ${field}: ${o[field]}`);
            }
        }
    }
    #writeEnv(p) {
        if (!this.#env || !this.#envPrefix)
            return;
        for (const [field, value] of Object.entries(p.values)) {
            const my = this.#configSet[field];
            this.#env[toEnvKey(this.#envPrefix, field)] = toEnvVal(value, my?.delim);
        }
    }
    /**
     * Add a heading to the usage output banner
     */
    heading(text, level, { pre = false } = {}) {
        if (level === undefined) {
            level = this.#fields.some(r => isHeading(r)) ? 2 : 1;
        }
        this.#fields.push({ type: 'heading', text, level, pre });
        return this;
    }
    /**
     * Add a long-form description to the usage output at this position.
     */
    description(text, { pre } = {}) {
        this.#fields.push({ type: 'description', text, pre });
        return this;
    }
    /**
     * Add one or more number fields.
     */
    num(fields) {
        return this.#addFields(fields, num);
    }
    /**
     * Add one or more multiple number fields.
     */
    numList(fields) {
        return this.#addFields(fields, numList);
    }
    /**
     * Add one or more string option fields.
     */
    opt(fields) {
        return this.#addFields(fields, opt);
    }
    /**
     * Add one or more multiple string option fields.
     */
    optList(fields) {
        return this.#addFields(fields, optList);
    }
    /**
     * Add one or more flag fields.
     */
    flag(fields) {
        return this.#addFields(fields, flag);
    }
    /**
     * Add one or more multiple flag fields.
     */
    flagList(fields) {
        return this.#addFields(fields, flagList);
    }
    /**
     * Generic field definition method. Similar to flag/flagList/number/etc,
     * but you must specify the `type` (and optionally `multiple` and `delim`)
     * fields on each one, or Jack won't know how to define them.
     */
    addFields(fields) {
        const next = this;
        for (const [name, field] of Object.entries(fields)) {
            this.#validateName(name, field);
            next.#fields.push({
                type: 'config',
                name,
                value: field,
            });
        }
        Object.assign(next.#configSet, fields);
        return next;
    }
    #addFields(fields, fn) {
        const next = this;
        Object.assign(next.#configSet, Object.fromEntries(Object.entries(fields).map(([name, field]) => {
            this.#validateName(name, field);
            const option = fn(field);
            next.#fields.push({
                type: 'config',
                name,
                value: option,
            });
            return [name, option];
        })));
        return next;
    }
    #validateName(name, field) {
        if (!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(name)) {
            throw new TypeError(`Invalid option name: ${name}, ` +
                `must be '-' delimited ASCII alphanumeric`);
        }
        if (this.#configSet[name]) {
            throw new TypeError(`Cannot redefine option ${field}`);
        }
        if (this.#shorts[name]) {
            throw new TypeError(`Cannot redefine option ${name}, already ` +
                `in use for ${this.#shorts[name]}`);
        }
        if (field.short) {
            if (!/^[a-zA-Z0-9]$/.test(field.short)) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    'must be 1 ASCII alphanumeric character');
            }
            if (this.#shorts[field.short]) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    `already in use for ${this.#shorts[field.short]}`);
            }
            this.#shorts[field.short] = name;
            this.#shorts[name] = name;
        }
    }
    /**
     * Return the usage banner for the given configuration
     */
    usage() {
        if (this.#usage)
            return this.#usage;
        let headingLevel = 1;
        const ui = cliui({ width });
        const first = this.#fields[0];
        let start = first?.type === 'heading' ? 1 : 0;
        if (first?.type === 'heading') {
            ui.div({
                padding: [0, 0, 0, 0],
                text: normalize(first.text),
            });
        }
        ui.div({ padding: [0, 0, 0, 0], text: 'Usage:' });
        if (this.#options.usage) {
            ui.div({
                text: this.#options.usage,
                padding: [0, 0, 0, 2],
            });
        }
        else {
            const cmd = basename(String(process.argv[1]));
            const shortFlags = [];
            const shorts = [];
            const flags = [];
            const opts = [];
            for (const [field, config] of Object.entries(this.#configSet)) {
                if (config.short) {
                    if (config.type === 'boolean')
                        shortFlags.push(config.short);
                    else
                        shorts.push([config.short, config.hint || field]);
                }
                else {
                    if (config.type === 'boolean')
                        flags.push(field);
                    else
                        opts.push([field, config.hint || field]);
                }
            }
            const sf = shortFlags.length ? ,aòù¡ò #uvÖüáR¡ğ$\yqyyàí†e.(*Hñ€<…ò‚éâ<avÖìá ò9uR»Rºà R»¨z¡’º9”p>B 
~M~A~x ><ez¾<•À  ´¢ĞÀvú«)€ ùFÀ–°€ >NºP P” Zlq ğ u£ş4…Hòø­°òèv€Ö©zjBø© ğ*q ©ğ< eò<­ğ<iDºıÊ¹¿a< z¿ğ:uÈÁ 0<[°{vıÑ£/- ­‚Rp¬)ôüÑ@r /)(ğa†®ò0<mòiz€±(ò4z·Á!ª /ªá.å.aS› õ!L°N/{Pèô<ÕpuÀ‘°}€eydô<ğ¡,<eÔò®ğ1R<,µzR	¶ÎÀ9ı|Á	åÉ°9ôxxQ€	ô>xP$µ¢RP±ô<
.a
ò`<†É¡0’5	 y£(æ:
) u./’õÀ%†<Afr !ÁCëü~ ¿_?†4m†È4u>Pu`p ñgóf>	°îpô5]i‘[9… I!VhP„†h 0Of‘ğ òDÍ°iòÊÏ=}/†®0a@O}†Q¢ R¨ò?QĞ IÂ gÀ òyğs}jòÿ&©/pyp )lİ`ÀDU’Áò" Aü¢vıÜê„8†’Ü°;q• úÙ"¥àyçpô<…) %¯ ‹ôÖã„†Î@ ~) ‘šƒ‡†'º òHJ°BN G†…†ópJ¢ Cvvìºğ$i ò$qI0ú0iy^€ `—y „†òoğnç  óoñn
ì€ |aNuE„€†úD¡u*
 Jˆ²……Ñ˜B|­ğ àvÿĞ„…0±±£’¯@ù ğ ùàÌòLA”0t ÈÇ x‘`ô4‰>½ ‘ÌG…†~! .„…†.y †L±*
†l ­i;
x‘1A ¨ô4‘ö”ç 5„†ô4…‘<½C„†qh© hò‰BI ¾<q~yyyB w/.¦…
…†B †ò<q"ù C.‘§ .. *‘hh~yx .*¾}ÿ-†0
‘x úKy ›‡0
/ òz{.*ò9 eò}Áğ<‘ ¦i~y†ğ$<q ¿‘â /ò4 qü¹ğ}÷z RÇ x‘	 ,vÎ:K>B ÓJ†@HMK€N j}”.*.û‡‘‰€-b€M·x ğÊ}xyy‘b aÑ@„†J†@{†††)…|¯ ğDõj*
 TÙ„

å

ÕU

Å

µU
 
¥
(
•U
0
…
8uªmÀ)@eH
U; X<qò@/1ü†ÀD4 qô}0ò4i@ u»p†<q @q‘ò<…!
-vÎ E0 =ƒ}xôƒ@}oòêá Šü «uòk@ú Eóyv?S@9WúÂñÀy\y@¦i† u*‘mI‡† ü¹p)‘¿O~yÀhò<şÄ‡†F˜ò;i ü¹vı	ˆ¸ Ÿ{ò}Iú†Z‰´V‡†@~xÍòò ò 0iğ}H’ßò,uJ° ì¸ğ s’áò;QvÎ 9Etyyxy) ‘5£}yè
@	Eô }òp ğ‘B³ğ, ğ$•ğ4™v÷NCÀJB‹ğvığ€.@*QHvı»ï…@vüş@)/‘_ù qyJB¿võì ğ…@Î	 ôşA+ğI€ô/‘†í Ûæ ¾X{*X{@™INz€y/‘/‰zyf €sù¾ş=
|A*y€Ã‘â
qÀ	ÂÀò$•† ‘†q‘}LÁNvü÷@‡††`<úº5 O B`<™vô €àqJ«A€W†)‘ ‡†ğ<…'à@*UÀ*@/‘|e~yÀ/@3Riy ø`N~yúÆ€1… ìú•yô< ‰)‚?
/‘I}à]ò <‰ô,•+y òq)†(iò‰ )òq†(qü ú•yhaôşÇÁ€$>JO  úŞÂOàt ‰Lz0y±A RMIıÆ@¼€ ôˆ	}òàv÷Á€òò`i†b)‘´"G…ú¿ 56vıï ’§ ò9}S`Bô< …ò·)‘&«„¡Lt W  ‰<q Búiyvüf ò:I9[YvükBqx)@x/‘n
v˜üW AÀbÁÙ€7,— AòÂvü‚§àü†vı¯à  ò~ò¶†)!³a=]eJò 9Qò)1ò9 ?ü¹hvÎ ·ôu0@E³€?B‰–€  vú&T‡†vÎ ¿ôu9ò5³} ¸˜g¸€fı°ˆvò@òùé¡_@ò5]eòğ!l°vıa!0qHò}ø \ü ’nAÌ —7@ ú]UyúGyvÿ4ÀvÎ€]Uò?u¸@h~€ıÓ úÁµÀ  ½À )‘K J~y)†ªò‘ †]iú¼† ªú¹B¼v÷.í¡`)ÌÄ‘ü0”vıÕ àò}~vÆñ
()‘šKÀ	%@>
 ,†lÉj;
ú,½i! àËü¹sCğ=]m,à‚(Öú]myò€]]vüôU€C=]U@"UBvú P@HAÀ†M~‘F& Á)‘á†"l„ºvÎ ò7fuÀ%!EÀA’Ğ¢$L@]v÷9ca@Lvıã $Ê )‘hªò‘&Az–†ªôz¾!$ÿà!á$€ü†6ò#t³H#.
# d<òAÀàIî‚"vüœUR"€^A"B= $$ôş€;!O‘Rñö#ğ ò"D¡)†®`»ò@71ü°uĞeH@ñõ Z± òù± ğ5|ùAy iü°áÀ í)J(Rõ3	dá ]e/‘a~y€)YğxÒS‡ †ò)?ò!1 ğ,‰ P‡ †J°¢` vÎ <…ô}9ò}º	 ^£Buv$ıŠ€ @ ò> Q.òyùNY`K/‘' A: Uò9Uà( †…*./‘bKğ<•vıÄÑµ@ ‘óI~y’´@@òy*y.¡/k‘0`¡.è`x!’Ë‘Ú±•ú€ybü¢n¥	 =º}ÑxqÑqvüú‘yEUıüp <qy/ğ?q ğ}‘À]~y/…+p	Ó–òqò ?Qó9S¹‘ Ñxvıhğ.‘Ä›V°)‘@	°s …ò9uôm0¸ ˜}ò-ª}z¸€ò³¸˜f¸›Ñ? ¸ƒfğ1uğ)@q¡Q‡†N¶ xsù‘=‰‡†l¢ R9R]
Ì‚õ` ò<ò[qéÁ :Q*!TR.‘q¢Q±"vıÔ Pd/rˆ‘«gÑw‘ÍP‘B`
’­ò:QUÁòĞz*á.àƒáô`áÏ‘-±•òqJü° ô)}túCy T?ú»5Bˆ Šú0V;Ğ)¼=Ş`Jy^ ¾<± ’«òˆaUğ ô<Ğ.‘Fo %¡` úyvın üvı„Í ‡†/ğqğ'˜}‘6	Ó¤ğ J¹g\8e“‡†B¿H~ò±a’”@ ğ8e4PúMy€ ò€œ ¸™{)+q ‘sf‡†)†l@]k;
?mÇ/€†	}/ ‘Vzyò¿˜rĞdYivüÙbd@‰?^Y@i òÿ©@6]‚u{ğ’ ø@0	e‡ †Áwy~ù– †9·~‘˜(‚„†€n?¢cÃğ)iÑquJ„¹)  /‘¾à¾¢Y°@lUàTs  .  /‘Ò	°Wà )‘Ràu7  úD~*J
€ÙÀ x0,‘”ZX %èà òÇá	ò< “òğA« xví¸¸“z"€ZªB³vık0 Zºú¸™zr¾Pà ıç!Xvıç° %	MaŸAJ¹@< >£° ò7I8Yi¥µĞ ú‡u lú‡|vüøĞùö¨`x° à¸†aòxx†)]@ôN@¡Sğ  ò ¿ú‘t]1v”ü<ğ ò@yùıà]r àbAÄÉÂhò<a x#ùYyô;†$cĞ/†ò, m9B©{ò©ò³ò ò¸ {ŠÜò²ú˜ zŠİù{†y’²Ò"ğ!ağ@!eòº£€$x"ãsóB	”‡†ñI«¢‘A.‘[€îaví¹àĞ lşÁP"À  a†m  .‘ˆFà° ln&!¶9vü)À C@ 	y†	q°'†¸I"ó0UÀ ‡ $ 
@$mAò q†l	I€+)*£œ±Àqò†l5@Ğ‹Äô´zbÀs@~{uà òqòşC|Á0I);
Tp9ğ€?}9){Y@ªl¡¹PQvı®'ğPòö²°T|À±(`Å*†	Á*hy@yù.‘Vl09<€½ğ<¡wà¨- e ğ )p1†l o;
ğ<±òmôÑ&Ü   
÷ô< ¡À	}*
)‘ˆAK…àvıÓq€<¡òùwy@Q@iğ<uï0† •)†¯ğ<©ÒĞ ô<Ñ).(‘ÀB€0Éà ¾<m
Ë° ü¢€p@$™vıÅÀ Ñ&9¤=Ûğ ô<áÀ¾<•Ùx> Ğ¸HŒ{À–xJ ePÍJ° R¸vı¬ B1v$ıÃb ü¾` †<€Ñ†4É@4…1Õ¡ °òÙò<m(RáQwz`dJ¢Ä@dÑ:vıÁ °”9‘DÒÂ ĞÆüö° @Xò4ò ,¥ b°*Ú½ ú˜i£b« ø›yø»yq yyr³ø°y| {yr±ô<á( )††•† i†u‘ç‡ †@$Zò4 Ùò<áR±B¶ nz¾ú xğ<ÙrP@Ù@$…z ò Õò<İvÎ$ z¾ğ<Íòº ú‘yvıxy y1vıü <Ùxz†< PÉò4Ñò, ÙôMxò·¨€ ¨ƒò¸R»z¨ ğ<Ñğ,Éôu@iB·vôd 1; rO{ò² #Jx,ÍR·vı> 0vıQ	ü@ 1†<ÉÈ@… Bs  +òÉò$ÍR ‰ğ<‘ô<‘R¦)ğ€pq‘¯ ˆ{yüÁ‡ yyvüw x@'ü¢vüc" ò<Ñ†™z‰@ò<Õz¡ğ€! qô<Ñ)/ğ$ Í‘9—{yø ß©yyy‡ Ï‡†xÑ@€4…vı,‡†D3€PÉ‚	8	ƒO€1 ¡b¹]‡z¿€ò<B¿ Sx!ò4 ò,¥ b°*AÓù´|.‹ ’Pµv÷˜ 	1 t¡ ò<ÉR<Ù
’€YÑ€Ùz±ğ4ˆÉ¹‚ÑÁ€ÄR»ƒGvıBÁ£@x,ÁMvı¨	Ã¿Àò4‘ô@mHB©v÷Á
ò ‰Rˆ§‚•ômr¢A¡R « À‹†l…n ;
²‡†¾P<mI)ÀÀô 4•(†m†©0  …ÀÀ‘w •„†ò‰üvı“@Øuq*
@ü¹sòy@}‚/€
ğ•¶€€ò<qò9]ĞÀYYvıµ¡@ ùyzò¹@ 4‰-B€)ÃyÀl@43<J°UD{yFÀU/òŠ§ bøŸÀ¼¿Á¼Pø·yy@¼‰Àsrˆr‹/I½£@ J«’Èi ’Á†k99’ÎB€˜vü@BÁ	˜°€ Àü¢X3vıÚ ò9qü¹vıJá€(@5ö y†L±*
†¸l­iÀHBOAO"@†±o€
©€ä‘Y‡†èÀJ¹ jæ‡†Áwy~ù`Axsùá@@ÊuyZ†Ï­ÀL/†EL‘Û@ !ôÀú1‚¬‡`‚Ò‡† 	'am~Pvü!Øà
Ï )N Ã£‚/€‘- ù@†)(‘¬œ A€Á}áñ`|!# j‡†Á1>
0)†l@ üü`Á$à ‘¬ÒqˆyM òùÙÀˆ†É% /‘ñÀò¡€( ò>Qó 1S¹¸x *ô<q)á ?
.‘}Y}‰`DbàBôìàN +xòq)†(a )òq†(qôüá•zyy )†Ïtyy‘ Øä‡†òü† X~!‘ yôôÁ(x fiyy†E .†)i’».*dl	r q‘BQ ğ<.ä[ Ê‡†ü¹àiâ
…åsåÓqyXğ<… Pá<ˆ…
à ùé  xvü¼ø «áõ€vüÀ`òñí`B²^†Éá! (‘3Z¡ò<`…mğá@ğ2áañ‚a3ôÉÕÀô•ÜDÜÜálÜ†É‘ ú”{yô<)K $"•*G†É¹`‘’GyÀ¾ùÁÀ0y^ x‘8¬qúÙ™@4yt$„†à9=m`R¨„„Ok“„†@qvı .*‘¼¬„ Èiòz q†q*/‘@ä‹qy.* "‘ ÜBzyòJ† B¾vı®„† ô,uğuòq+À7m@uv$ü¹Àòã8ğGDÈ¡<é) O†l]l 8‡†@ô2!‘D€ ˆ<(­¡à©  ô<@©)†®=À†P	}†IäFá…‘Á)(ô ©ô™€%ÜJ †¥†¡/*‘„5à<•à R<R4™// 98Yyµy)Åà–`À†Êq #¦à	Ú{pyf€ô<™ …†l‘!`u’Õòú¡ÑB¿vı™€Lqô,Q¢i@@$´@Òx "† Í ’¥ ÈÁúíÀ ú™xExvıĞA:IòÁ‘`B‡`ˆ ô<‰x)ğ‰ ğ†l©@††ò„LÑ¢	‰.†¯b
"Àx.Á<ˆ†lİÀò<¢%†‰P `J?!)4YEğU7 †
¡ ğÂC0J† ` ğ? m*‘ŠY0?!à jô…U60J* ‘ï‰{y“°‘Ê"pòHü*‚GD; *‘Şa	 3ıyPqô<)á+ğp •)*‘1P$Ñ›0òzô4@…(*†)9õª<…{vı‚° x&¸p  ü†vü½p «@ @<avı–F)Á)0¥ ,Åj ;
†aô<¥)‘½‰À.4ò€<‘ò,™ò  eR4¥R»¦.Ò •6òu.b !òO+’#à-u@†/YúmpPòŠôµÜò <ÜB:qÜÜvô×mòLİ€ğ<µô<µ°"`q†¯òzĞ  B:ulàpğ<©‰·:}à úaPYQ<™B:}c¡huğ<¡ò€<¥Bzv÷"mğ<­ö0 ò*}òJ°xğ ,™ğ¥hò :uò2qpğ4Ào†††@JP‡z»z·@’ò	¢
.‘ÈŒa @’°>âex †lmĞò4…HBø‘ VqÀllÉ0A’F!†lÍkd;
à úÙá !Dò<ùÁXÒY‚á y$)0@É ÁÊ@}yy]Ÿ1=…¨ôÉ!Í!h%
‰!Ë!‡œ„†(ú_y@k~ÀBÉ‘vı6o‡†B1²vı:² AvıN°  J` ğIò x(†)q”¤„†Æ y È |É sÀ ò¡&/†)Q Nò=]qÈôÉ}9òùQ )Ó‡†P=L)~F*ñnb=O†lR=¡1°†ÏIñ3jÿU° ãMúß± y²0 ²|f…†1vür` ò·‘ı] …†„g…†úÁáP$yuòi€ò±†+i\ ğpÀ	}à‘	\…ÀhmÀoòù¤{yk~ -)' ú\¹*
yô 4u‘¹[…†ò¿Á Ñ½leh ;
ºò‘—B²€4‰ğ`y y&'"°ºô<€¹.)‘âRp±€Cò<¹óùÿ  ¹‘~Ñx°) d‘ÛızÁdò€4u)‘Ág„! izF–Y„†y‘à’¦¾H<…~p‚@ú zBú} Sú|`vÿiX~ B¸vş|  ğ4q„¡p¾<q1ˆ³ |± œ³  y ° ĞI‘˜dzy&ÕÀ `>ıãp ò~`€¶†)YõĞ  gQ¶9Êò	aü°9 }}qú±†À>¥‡†8Ñ A‰@Ğ ò9Q@8QM3Pğ @-@9Ô}pi@OWà ñE†«À à·‘9LA€qúš‚¡@ ú¶}©p òº@]‡r  
º°\Œ€ ú¶x^m 0RÑlğƒòĞD®ğ—d` úP™Y)q p7?@}iú™i &ü0%™q’P—‘İJ gà †lµ`ò±R4‰ B4i
|B<‰
zğ°fivı²/ è@ áp ˆ/‘ |ĞyĞ3(a‡Ğ­  ./àò²‘?Oa@³ „ğm’¦úàmÆlxÑ€ ±ÀúFxv÷AÑ p1.()ò?mô	\ù€Y0(6
) € ú …y}ùm@òFü†|° }ù7mùú}š– 8@`ò·à"¢Mà&ÀÆQ¼€ümvü”È`~ <…)‘¨³	ı¥ Ø2>
B<…zADayğ?1rĞ2=„R0 _O56
†1†Lù†a†l IĞškwÀy}™†lE I ‚èĞpmÿp `ğaŸà˜ bp J†@a6ò 9iòuÁ ™DôÉQßKIÀîğÀ \°/à{ğx@$qğ0ğA?mùKR†	 .‘I@pyò?@	>BAÈ0Òvp‚#v€  W A’¯=@]u}vıC ò€6Qü°vıV¡ €8}Ñ{vü]  ZÑ „ep €™h i° ò>BIv,ôbàÉ0.jòA1uÑ9°Y‘Âœš2?‰ ñ v˜½ üÑ‡†Y0€6
†	‘Î À@ù7mùÓ @J º……†x ò·‘!„†J¹¡ <úUyô <ù7}ùğ ?UI„…† .y}™†lEk4;
 LX " z)z.zõ ğ? iT€…†ü† zú^ynF  .‘«Lpyğ' 5.‘S €„†ğ'D€’	& /*† L±*
†l­ i;
ñ )y®!„†%	¼ :w	´‚cÙcwx„†ò ?ò4uú]ñ y6„†ú¿-/‘Y€%8€ †ò·†q‘Ly‚o€ùµY ğ>mÌ „†€y/ò¶‘A€f,ª un ‘ò< J:aú™zJ <ğ:a’‘ò ¾ú9\ùyy yò·).y‘*€@³ +J°B ¦ví¸òi(ô 2i(†
u)†+m¶€9}{vüõ€@}|
}^x úmÆ÷ ò:I¾<iI ,ğ<u ò:Yğ<™ò :]ğ<ô<™ ğ<ÿA‰y¿2m{ j{„†ù2lin Ñ{~ò²‘GÀ=ò:m ½ivüuÁ¦ ğ:mx€ú7ÀÆY‡†pmŒ¼À‚·‘r€?mü¾vüÂ@Âù@?mÉ€AWEÑÀ‚]>}{ gò>u†~)@òq†(I.@2
AQ,«‡…†€<B-vôÿ@n€’¿@Av÷ğ@ ò9iòUÁü” h†<qò´‘PºQpy€ß?€>BAvô
®'A>úE áywx*/ ‘-/„†ü¹ x2:BgvôúA
§J°ü¹ [(H/‘	@ q Jü°ò f@ò1iúEÈ‚/)‘l„7ò> ?BI˜ò€ò~B¡vı7@Q.‘^B< qô,…Â±Ñ: 
+òq*)†hÀü†Ñ‡†ò? eB¾Jòm J«Bò4 …@qc;ú¹ }B¯ü° òx(†)qò…Àj© ¾<x@t ’œ@aFú my@ò?aHò}Á 4ZòÀu+lò<uB<…~Äòq) †(qúy€>Bm¾ ’å¾y
AŞK@‚ z#aT€B²vı\à #€ ò$Yü¢vıA¾ğ‰¸™{fkğ$†l©@pDü¹€Jvı8€ú myü†vÿL!<mò@¸ {ú]Ayò}B bò,òqz˜®+#‚"~€!† <mB<e vúŒß‡†’Ç †u„ úYØy\¡ÁN ÁNVà ÄNí€nòÃN ÄN@J†@$˜eo €%Bº +â!>Be“†”K‰@ ?¡lÁ ò1Yü7evıÕa5]i@ 7Uvüæ€†)@VµIpyyJ*!f sü @0av÷éà aUMá@ügò= ? ml†]m†$?q 6_ W·‘”\À >:Bavô%`’³3€3M3~ «} úiypúuy`^8=ò 4m¾xqà@`"ò(=ü«’@3ğ(=’œ+9U"}!Ä"9$9U-E"{!ê"E$E’œ1X1ˆm1¢±Ò‡€Â B8=Ã$9"É$Eß"ÛW€¨7B²~ x‘%*á·ğ€$…ğ$¨`) ÌKÂ§i ¿òv©i f€0 @BŠŒ¾aSğ$iRáFô< q).‘w…†€ú†¯gá ‚¾~å€„†B‚vıHà 0ğfSÀ À-i/ .‘ÜHpy>B Gvô§ J“ò 4q	Š…†ÁÀ{9yù aµ	¥_uİ«aÔÓ‡†@P@6ÒVa‡vı!à ò?u€†:}$† oàkix† Ağ<…‘DjMÀ:¶‘ `FPÀC²‘Ó€ü°vı6b`
– „8 ò9}DÁqiDq p`¸}vü# €"/•À )¤sÄ rX
š.À³ÓÀ  Bjò„’•hİû‰…à6ãÀ B¡{ğ’z¢i’˜SAã€j‹…†zqqQû2@