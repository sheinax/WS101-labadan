'use strict';

var identity = require('../nodes/identity.js');
var stringify = require('./stringify.js');
var stringifyComment = require('./stringifyComment.js');

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = identity.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemI citate, preden jih pošljete v Word?Ne, nadaljujOglejte si citate z! ali x za dokončanjeZbiranje …$1 od 5,0Sklici({0})Oblika citata $1APA 7ChicagoIEEEHarvardMLAMeni citatovCitatSlog citata $1Citat v besediluCeloten citatIzbran je slog $1Pošlji v Word$1 želi deliti zbirko z vami.{NUM_COLLECTIONS, plural,
    =1 {1 zbirka je odstranjena}
    one {# zbirk je odstranjenih}
    two {# zbirk je odstranjenih}
    few {# zbirk je odstranjenih}
    other {# zbirk je odstranjenih}}Nova zbirkaVsebino, ki jo želite dodati, povlecite sem{NUM_SELECTED, plural,
    =1 {# izbran element}
    one {# izbran element}
    two {# izbrana elementa}
    few {# izbrani elementi}
    other {# izbranih elementov}}Nedavno uporabljenoMoje ZbirkeArhiviranoRaziščiVideti je, da nimate vzpostavljene povezave. Preverite internetno povezavo in poskusite znova.Ali manjkajo zbirke?Vaši podatki so še vedno na voljo na tem mestu. Do njih lahko dostopate naPomagajte nam odpraviti težave s temi koraki1. Ponastavite nastavitve brskalnika.2. Preverite, ali deluje v drugem omrežju Wi-Fi.3. Pošljite povratne informacije.zbirkevsebina zbirkeime zbirkenaslov{NUM_SELECTED, plural,
    =1 {Deli izbrano, # izbran element}
    one {Deli izbrano, # izbran element}
    two {Deli i