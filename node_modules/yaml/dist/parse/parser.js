'use strict';

var cst = require('./cst.js');
var lexer = require('./lexer.js');

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
    *Ó ~"5Ó "ÀÓ "ğÓ ƒ"0Ô „"nÔ ‡"¨Ô ˆ"ßÔ ‰"Õ Š"Õ "(Õ "RÕ "eÕ "±Õ ‘"ÙÕ ’"Ö “"?Ö ”"pÖ •"ŒÖ –"°Ö ˜"·Ö ™"ßÖ  "÷Ö ¡"*× ¤"z× ¥"¡× ¦"í× §"Ø ¨"•Ø ©"¶Ø ª"½Ø «"ÀØ ¬"ĞØ ­"	Ù ®"‘Ù ¯"]Ú °"Ú ±"Û ²"8Û ³"dÛ ´"ÃÛ ¹"ìÛ º"
Ü »"Ü ¼"Ü ½"Ü ¾"Ü ¿"Ü À"Ü Á"DÜ Â"`Ü Ã"Ü Ä"¤Ü Å"µÜ Æ"ïÜ Ç"]İ È"~İ É" İ Ê"Îİ Ë"Ş Ì"#Ş Í"7Ş Ï"zŞ Ñ"•Ş Ò"îŞ Ó"¸ß Ô"èß Õ"à ×"|à Ú"–à Û"¶à Ü"	á Ş"sá ß"¢á à"Ùá á"Zâ â"sâ ã"Ïâ ä"ıâ å"{ã æ"±ã ç"qä è"‡ä ê"Ùä ë"å ì";å í"må î"Óå ï"Iæ ğ"zæ ñ"óæ ò"Fç ó"mç ô"Mè õ"è ö"é ÷"é ø")é ù"Lé ú"ué û"€é ü"‹é ı"¥é ÿ"<ê  #bê #‘ê #¶ê #àê #ñê #0ë #Ië #–ë #Èë 	#èë 
#@ì #jì #ì #Ìì #í #<í #kí #îí #î #7î #eî #¦î #úî #:ï #iï #›ï #Êï #ğ #Iğ #Sğ  #ñ !#ñ "#hñ ##¸ñ $#»ñ %#Åñ &#Íñ '#Òñ (#Õñ )#âñ *#ïñ +#%ò ,#6ò -#Hò .#Zò /#“ò 0#ò 1#àò 2#éò 3#øò 4#ó 6#ó 7#Gó 8#jó 9#‰ó ;#™ó <#¼ó =#Íó >#éó ?#ô @#ô A#ô B#ô C#†ô D#—ô E#£ô F#®ô G#Àô H#ıô I#õ J#/õ K#Eõ L#Iõ M#Uõ N#jõ Q#sõ R#}õ S#’õ T#¢õ U#¬õ V#Áõ W#Òõ X#àõ Y#ğõ Z#ö [#3ö \#Sö ]#oö ^#Òö _#üö `#1÷ a#=÷ b#¥÷ c#µ÷ d#Ê÷ e#Ø÷ g#Gø i#Vø j#qø k#€ø l#Œø m#³ø n#şø o#Eù p#Zù q#wù r#°ù s#éù u#€ú v#Ñú w#İú y#&û z#8û {#sû |# ü }#Nü ~#ìü # ı €#ı #ı ‚#Eı „#ƒı …#Ÿı †#·ı ‡#ş ˆ#.ş ‰#˜ş Š#¥ş ‹#ºş Œ#äş #…ÿ #˜ÿ #Äÿ ‘#@  ’#o  “#€  ”#Ø  •#ğ  –#	 —#] ˜#© ™#Ê š# ›## œ#A #í #" ¤# ¥#² ¦#Ü §#í ¨#; ª#v «#  ¬#Á ­#ô ®#A ±#k ²#‡ ´#½ µ#	 ¶#" ¸#n »#˜ ½#Ü ¿# À#5 Ä#g Æ# È#Î Ì#÷ Ñ#6	 Ó#r	 Ô#w	 Õ#}	 ×#	 Ø#’	 Ù# 	 Û#¹	 Ü#Ç	 İ#Ó	 Ş#Ş	 ß#ç	 à#ò	 á#
 â#
 ã#
 ä#!
 å#-
 æ#;
 ç#F
 è#c
 ë#q
 ì#­
 í#à
 î#I ñ#s ò#« ô# õ# ö# ÷#7 ø#M ù#~ ú#Š û#¹ ü#É ı#ø ş# ÿ#7  $B $q ${ $ª $à $ $& $Î $ë 	$ $8 $I $c $j $y $¨ $× $ $0 $o $ $¥ $¿ $ $ $1  $I !$c "$« #$Ã $$à %$õ &$ '$ ($< )$T *$n +$Œ -$¢ .$± /$¾ 0$Á 1$Æ 2$Ê 3$Ø 4$è 5$÷ 6$ 7$# 8$9 9$n :$¥ ;$³ <$Ã =$Ë >$Ù A$ã B$  D$ F$0 G$À H$Ñ J$ã K$ L$ M$  O$? P$Z Q$n R$ S$— T$® U$» V$Î W$ó Y$t \$ä ^$õ _$M `$Ï a$ì b$ c$D d$Ÿ e$Â f$‘ g$Ä h$İ i$ÿ j$K k$z l$È m$C n$£ o$'  p$P  q$Î  r$ø  s$" t$‘" u$Æ" v$Î" w$â" x$# y$-# {$Y# |$p# }$}$ ~$¤$ $Ò$ €$ÿ$ $6% ƒ$& „$J& …$¤& †$È& ‡$Í' ˆ$ş' ‰$Ì( Š$) Œ$) $½) $=* $y* $d+ “$r+ ”$¤+ •$í+ –$9, —$w, ™$, š$, ›$¨, œ$¯, $Ñ, ¡$ò, ¢$- £$6- ¤$R- ¥$b- ¦$- ¨$©- ©$È- ª$à- «$. ¬$-. ­$T. ®$|. ¯$¶. °$Ï. ³$ü. µ$í/ ¶$0 ·$10 ¸$S0 º$m0 »$³0 ¼$Ô0 ½$1 ¾$V1 À$q1 Á$2 Ã$2 Ä$X2 Å$©2 Æ$3 Ç$3 È$K3 É$–3 Ê$½3 Ë$ä3 Ì$4 Í$U4 Î$t4 Ï$5 Ğ$C5 Ñ$¥5 Ò$"6 Ó$Ü6 Ô$7 Õ$37 Ö$Q7 ×$j7 Ø$“7 Ù$¦7 Ú$º7 Û$è7 Ü$	8 İ$*8 Ş$N8 ß$l8 à$š8 á$Æ8 â$å8 ã$9 å$>9 è$O9 é$`9 ê$ƒ9 ë$±9 ì$Ñ9 î$å9 ñ$o: ò$…: ó$; ô$*; õ$N; ö$Ô; ÷$÷; ú$< û$-< ü$E< ı$`< ş$s< ÿ$‰<  %£< %¶< %Â< %È< %@= %P= %s= %´= %ş= 	%> 
%Q> %¢> %½> %? %'? %=? %Z? %g? %q? %? %“? %¥? %²? %Û? %@ %&@ %*@ %0@ %@@ %D@ %P@ %`@  %ƒ@ !%“@ "%¿@ #%ã@ $%›A %%ÇA &%şA '%B (%0B *%?B +%SB ,%gB -%qB .%›B /%ÒB 0%BC 1%‹C 2%œC 3%«C 4%ºC 6%ÔC 7%D 8%AD 9%ùD :%	E <%4E =%CE >%XE ?%lE @%E B%”E C%ŸE D%şE E%:F F%KF G%ƒF H%šF I%³F J%ÍF K%éF O%úF P%G Q%ÄG R%CH T%I U%I V%0I W%CI X%XI Y%J Z%ÃJ [%ˆK \%L ]%L ^%#L _%8L `%YL a%ÏL b%ùL c%¨M d%bN e%
O f%¾O g%üO k%P l%ƒP m%¨P n%¾P o%ĞP q%×P r%åP t%ïP u%Q w%YQ y%ƒQ z%–Q {%¶Q |%ÎQ }%øQ %ŸR ‚%S ƒ%}S „%T …%+T ˆ%CT ‰%xT Š%±T ‹%ÁT Œ%ÚT %FU %„U %°U %ÈU ‘%ıU “%ŒV ”%¾V –%1W —%cW ˜%‚W ™%‡W š%™W ›%§W %ÂW Ÿ%ÌW ¡%ÜW ¢%X £%>X ¤%YX ¥%§X ¦%Y §%’Y ¨%²Y ©%ÓY ª%íY «%Z ¬%=Z ­%sZ ®%Z ¯%’Z °%[ ±%	\ ²%=\ ³%â\ ´%ú] µ%y^ ·%ø^ ¹%
_ º%_ »%B_ ¼%W_ ½%o_ ¾%Æ_ ¿%` À%-a Á%0b Â%µb Ã%5c Å%?c Æ%nc Ç%–c È%d É%#d Ê%9d Ë%Zd Ì%sd Í%e Î%Äe Ğ%ïe Ñ%rf Ò%õf Ó%¢g Ô%Ñg Õ%îg Ö%h ×%Eh Ø%}h Ù%#i Ú%j Û%Mj Ü%~j İ%k Ş%k ß%ok à%Øk á%æk â%õk ã%$l ä%^l å%”l æ%m ç%¢m è%Õm é%Ôn ê%p ë%Up ì%·p í%gq î%´q ï%ïq ğ%r ñ%"r ò%:r ó%~r ô%¼r õ%úr ö%Fs ÷%¦s ø%ªs ù%És ú%:t û%®t ü%¹t ı%èt ÿ%ÿt  &'u &`u &Êu &v &)v &4v &v &Úv &$w 	&ow 
&§w &Èw &şw &Wx &qx &„x &Õx &|y &‰y &ìy &‡z &>{ &¤{ &ë{ &~| &Õ| &º} &Õ}  &~ !&B~ "&u~ #&±~ $&ß~ %&í~ &&# (&+ +&i ,&y -&Œ /&œ 0&¬ 2&» 3&Æ 4&Ö 5&„ 6&ƒ 7&9ƒ 8&?ƒ 9&sƒ :&„ <&¬„ =&Á„ >&í„ A&† B&D‡ C&ˆ‡ E&ˆ F&^ˆ I&fˆ N&vˆ O&†ˆ P&¯ˆ Q& ‰ R&%‰ S&Ú‰ T&Š U&†Š V&åŠ W&N‹ X&“‹ Y&Ÿ‹ Z&Í‹ [&6Œ ]&TŒ ^&nŒ _&ŒŒ `&±Œ a&ÆŒ b& c&I d&¾ e& g& i&/ j&c l& m&; n&u p&¢ q&å r&* u&e v&x w&¤ x&@‘ y&j‘ z&Æ‘ {&õ‘ |&’ }&/’ ~&8’ &K’ €&W’ &·’ ‚&-” ƒ&b” „&‘” …&¥” †&¹” ‡&Ê” ˆ&Ü” Š&ï” ‹&ı” &é• &– &d– &u– ‘&‹– ’&È– “&¡— ”&±— •&à— –&ö— —&d˜ ˜&˜ ™&I™ š&j™ ›&v™ œ&Ş™ &„š &‰š Ÿ&™š  &Íš ¡&*› ¢&Á› £&Û› ¤&õ› ¥&!œ ¦&=œ §&Gœ ¨&]œ ©&ğœ ª&4 «&m ¬&ˆ ®&0 ¯&À ±&Ü ²&Ÿ ³&Ÿ ´&6Ÿ µ&RŸ ¶&YŸ ¸&Ÿ ¹&›Ÿ »&¯Ÿ ¼&µŸ ½&ÄŸ À&ÔŸ Á&çŸ Â&şŸ Ã&  Ä&E  Å&m  Ç&¡ È&+¡ Ê&C¡ Ë&µ¡ Ì&B¢ Í&#£ Î&¢£ Ï&è£ Ğ&c¤ Ñ&~¤ Ò&¤ Ó&°¤ Ô&Ú¤ Õ&A¥ Ö&p¥ ×&–¥ Ø&¶¥ Ù&0¦ Ú&‹¦ Ü&³¦ Ş&n§ â&§ ã&©§ ä&4¨ å&À¨ æ&T© ç&s© ë&¡© ì&´© í&É© î&ô© ï&¾ª ğ& « ñ&ş« ø&7­ ù&q­ ú&§­ û&À­ ı&æ­  'ò­ '-® '£® 'à® 'æ® '¯ 	'W¯ '{¯ '‰¯ '´¯ 'ø¯ ':° 'B° 'q° '”° '± '1± '¥± 'Ñ± '	² '-² '9² 'D² 'N² 'š² 'ğ²  '³ !'V³ "'Š³ #'º³ $'ï³ %'%´ &'~´ ''ú´ ('>µ *'®µ +'¶ ,'¡¶ -'±¶ .'Ø¶ /'ï¶ 0'ÿ¶ 1'· 2'<· 3'n· 4'©· 5'Ñ· 6'İ· 7'ë· 8'ò· 9'ú· :'¸ ;'¸ <'2¸ ='G¸ >'V¸ ?'¢¸ A'1¹ C'7¹ D'W¹ E'¸¹ F'İ¹ G'º H'º I'*º J'2º K'Uº L'Áº M'üº N'+» O'h» P'©¼ Q'Ò¼ R'û¼ S'½ T'-½ V's½ W'œ½ X'è½ Y'2¾ Z'Š¾ ['ß¾ \'¿ ]'“¿ ^'¼¿ _'
À `' À a'VÀ b'À c'±À d'ÙÀ e'ÜÁ f'‹Â g'¿Â h'îÂ j'#Ã k'JÃ l'Ã m'›Ã n'¾Ã o'äÃ r'Ä s';Ä t'bÄ x'—Ä y'ÛÄ z'şÄ |'Å €'MÅ '©Å 'áÅ '-Æ ”'©Æ •'öÆ –'5Ç —'òÇ ˜'È ™'jÈ š'ŒÈ ›'ëÈ œ'É 'NÉ 'ÌÉ Ÿ'Ê  '˜Ë ¡'ÇË ¤'Ì ¥'EÌ ¦'Ì ©'ßÌ ª'Í ¬'#Í ­'WÍ ®'‘Í ¯'éÍ °'‘Î ±'ğÎ ³',Ï ´'>Ï ·'ŠÏ ¸'–Ï ¹'«Ï º'ÁÏ »'ÊÏ ¼'„Ğ ¾'ÓĞ ¿'BÑ À'¯Ñ Á'İÑ Â'ğÑ È'Ò É'jÒ Ë'µÒ Ì'õÒ Í'NÔ Î'@Õ Ï'¬Ö Ğ'¶× Ñ'å× Ò'-Ø Ó'_Ø Ô'–Ø Õ'lÙ Ö'¾Ù ×'Ú Ù'<Ú Ú'}Ú Û'ùÚ ä'3Û å'>Û æ'rÛ ç'¨Û è'ëÛ é'OÜ ê'hÜ ë'uÜ ì'ÓÜ í'gİ î'ˆİ ï'Æİ ğ'àİ ñ'%Ş ò'ŒŞ ó'™Ş ô'µŞ õ'ÛŞ ÷'ß ú'Bß û'eß ü'Äß ı'`à ş'âà ÿ'fá  (Ÿá (Qâ (Êâ (9ã (mã (Šã (tä (¬ä (0å 	(Xæ 
(kæ (¶æ (sç (³ç (Ãç ()è (Aè (¤è (é (+é (Lé (”é («é (´é (ê (;ê (Òê (êê  (ıê !(ë "( ë #(ƒë $(—ë %(ì &(ì '(+ì ((†ì )(­ì *(í +(Jí ,(”í .(î 0()î 1(7î 2(Iî 3(Yî 4(eî 6(†î 7(“î 8(™î 9( î :(¯î ;(öî <(vï =(‡ï >(¹ï ?(Ùï @(ëï A(-ğ B(‰ğ C(ğ E(¨ğ I(Äğ J(îğ K(0ñ T(ëñ U(ò V(Tò W(”ò X(íò Y(ıò Z(Dó [(˜ó \(Ûó ](yô ^(’ô _(ãô `(2õ a(}õ b(ğõ e(Pö f(ö g(¹ö h(øö i(÷ k(S÷ n(€÷ o(«÷ p(Æ÷ q(Õ÷ r(*ø u({ø w(¶ø y(öø z(Dù |(…ù }(ù (¬ù €(Æù ‚(öù ƒ(ú „(&ú …(Šú †(µú ‡(Ìú ‰(òú Š(û ‹(û Œ(eû (ïû (<ü ’(šü “(¸ü ”(Úü •(óü ˜(`ı ™(‚ı š(®ı ›(æı œ(_ş (Õş (çş Ÿ(øş  (ÿ ¡(,ÿ ¤(Mÿ ¦(¡ÿ §(²ÿ ©(Ûÿ ª(óÿ «(  ¬(.  ­(s  ®(à  ¯(˜ °( ±(" ²() ³(? ´(ß µ(+ ¶(L ·( ¸(‹ ¹(í º(O ¼(¹ ½(¿ ¾(Å ¿(È À(Ö Á(î Ä(õ Å(ş Ç( È( É(+ Ê(: Ë(K Ì(\ Í(j Ï(} Ğ(‰ Ò(¥ Ó(À Õ(1 Ö(¸ Ø(Ø Ú( ä(w å(ˆ æ(® è(Â é(Ï ê(İ ë(ä ì(ş í(H î(S ñ(` ò(n ó(” ô(£ õ(Á ö(ş ÷(	 ø(	 ù(@	 ú(l	 û(‹	 ü(Ê	 ı(ì	 )J
 )q
 	)y
 )«
 )³
 )Ë
 )Ô
 )ê
 )ú
 )J )0  )¤ &)² ')Í ()Ô )) ,)1 -)` .) /)· 0)à 1)E 2)ˆs.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine &&
                this.indent === map.indent &&
                it.sep &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;
