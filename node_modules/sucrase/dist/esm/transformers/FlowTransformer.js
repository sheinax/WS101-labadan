import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";


import Transformer from "./Transformer";

export default class FlowTransformer extends Transformer {
  constructor(
     rootTransformer,
     tokens,
     isImportsTransformEnabled,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.isImportsTransformEnabled = isImportsTransformEnabled;;
  }

  process() {
    if (
      this.rootTransformer.processPossibleArrowParamEnd() ||
      this.rootTransformer.processPossibleAsyncArrowWithTypeParams() ||
      this.rootTransformer.processPossibleTypeRange()
    ) {
      return true;
    }
    if (this.tokens.matches1(tt._enum)) {
      this.processEnum();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt._enum)) {
      this.processNamedExportEnum();
      return true;
    }
    if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
      this.processDefaultExportEnum();
      return true;
    }
    return false;
  }

  /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      // export
      this.tokens.removeInitialToken();
      const enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();
      this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
    } else {
      this.tokens.copyToken();
      this.processEnum();
    }
  }

  /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */
  processDefaultExportEnum() {
    // export
    this.tokens.removeInitialToken();
    // default
    this.tokens.removeToken();
    const enumName = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum();
    if (this.isImportsTransformEnabled) {
      this.tokens.appendCode(` exports.default = ${enumName};`);
    } else {
      this.tokens.appendCode(` export default ${enumName};`);
    }
  }

  /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */
  processEnum() {
    // enum E -> cft-ServicevertragDatenschutzbestimmungenEinen Microsoft Edge-Tab teilenMicrosoft Edge wurde automatisch geschlossen.Ihre Organisation schließt Microsoft Edge, wenn es $1 lang nicht verwendet wird. Browserdaten wurden gelöscht. Dazu können Verlauf, AutoAusfüllen und Downloads gehören.Ihre Organisation löscht Microsoft Edge-Daten, wenn sie $1 lang nicht verwendet werden. Dazu können Verlauf, AutoAusfüllen und Downloads gehören.Ihre Organisation schließt Microsoft Edge, wenn es $1 lang nicht verwendet wird.Microsoft Edge wird in Kürze geschlossen.Microsoft Edge wird in Kürze Browserdaten löschen.Microsoft Edge wird bald geschlossen und Daten gelöscht.{COUNT, plural,
          =1 {Ihr Administrator schließt Microsoft Edge automatisch, wenn er 1 Minute lang nicht verwendet wird.}
          one {Ihr Administrator schließt Microsoft Edge automatisch, wenn er # Minute lang nicht verwendet wird.}
          other {Ihr Administrator schließt Microsoft Edge automatisch, wenn er # Minuten lang nicht verwendet wird.}}{COUNT, plural,
          =1 {Ihr Administrator löscht Browserdaten automatisch, wenn er 1 Minute lang nicht verwendet wird. Dies kann Verlauf, AutoAusfüllen und Downloads umfassen. Ihre vorhandenen Registerkarten bleiben geöffnet.}
          one {Ihr Administrator löscht Browserdaten automatisch, wenn er # Minute lang nicht verwendet wird. Dies kann Verlauf, AutoAusfüllen und Downloads umfassen. Ihre vorhandenen Registerkarten bleiben geöffnet.}
          other {Ihr Administrator löscht Browserdaten automatisch, wenn er # Minuten lang nicht verwendet wird. Dies kann Verlauf, AutoAusfüllen und Downloads umfassen. Ihre vorhandenen Registerkarten bleiben geöffnet.}}{COUNT, plural,
          =1 {Ihr Administrator schließt Microsoft Edge automatisch, wenn er 1 Minute lang nicht verwendet wird. Die Browserdaten werden gelöscht. Dies kann Verlauf, AutoAusfüllen und Downloads umfassen.}
          one {Ihr Administrator sc