EdgeMenaxho parametrat e miLidhjet nga Outlook hapen në Microsoft Edge për të përmirësuar përvojën tëndeKur të hapësh lidhjet në Microsoft Edge, shih emailin përkrah faqes që ke hapur, pa ndërruar aplikacionet.
    <br><br>
    Pas këtij mesazhi, këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Shih emailin përkrah faqes që ke hapur, duke klikuar në ikonën e Outlook në shiritin anësor kur hap lidhjet në Microsoft Edge.
    <br><br>
    Këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Shih emailin përkrah faqes që ke hapur, duke lëvizur mbi ikonën e Bing dhe duke klikuar në ikonën e Outlook.
    <br><br>
    Këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Shih emailin përkrah faqes që ke hapur, duke klikuar në ikonën e Outlook në shiritin anësor kur hap lidhjet në Microsoft Edge.
    <br><br>
    Pas këtij mesazhi, këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Shih emailin përkrah faqes që ke hapur, duke lëvizur mbi ikonën e Bing dhe duke klikuar në ikonën e Outlook.
    <br><br>
    Pas këtij mesazhi, këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Ky parametër ndikon në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365 dhe mund të ndryshohet në Outlook.Lidhjet nga Outlook hapen në Microsoft Edge, shfletuesi i vetëm i integruar me vlerat e Bing të mundësuar nga AILidhjet nga Outlook hapen në Microsoft Edge, shfletuesi i vetëm i integruar me vlerat e Bing Chat të mundësuar nga AIQasu te ko-piloti për uebin, e mundësuar nga AI kur hap lidhjet në Microsoft Edge.
    <br><br>
    Këtë parametër mund ta ndryshosh në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Qasu te bashkë piloti për uebin, e mundësuar nga AI kur hap lidhjet në Microsoft Edge.
    <br><br>
    Pas këtij mesazhi, mund ta ndryshosh këtë parametër në çdo kohë në Outlook. Kjo do të ndikojë në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Lidhjet nga Teams hapen në Microsoft Edge, që të mund ta shohësh bisedat pa ndërruar aplikacionetKy parametër ndikon në lidhjet e hapura nga aplikacionet e mbështetura të Microsoft 365 dhe mund të ndryshohet në Teams.Paralajmërim: parametrat e tu të Microsoft Edge ruhen në një njësi të rrjetit. Kjo mund të rezultojë në ngadalësime, ndërprerje apo edhe humbje të të dhënave.Përmirëso produktivitetin me qasje të shpejtë tek biseda e Teams ndërsa shfleton.Kur hap një lidhje nga Teams, Microsoft Edge e bën kryerjen e shumë detyrave njëherësh më të lehtë duke të shfaqur bisedën nga e cili ke ardhur krahas uebit. <a id="nurturing-link-1" class="nurturing-link" href="#">Mëso më shumë</a>Qasu shpejt në bisedën e Teams pa ndërruar aplikacionetShih bisedës përkrah faqes që ke hapur, pa ndërruar aplikacionet kur hap lidhjet në Microsoft Edge.
    <br><br>
    Këtë parametër mund ta ndryshosh në çdo kohë në Teams. Kjo do të ndikojë në lidh,
      keepUnusedImports: _commander2.default.keepUnusedImports,
      preserveDynamicImport: _commander2.default.preserveDynamicImport,
      injectCreateRequireForImportRequire: _commander2.default.injectCreateRequireForImportRequire,
      enableLegacyTypeScriptModuleInterop: _commander2.default.enableLegacyTypescriptModuleInterop,
      enableLegacyBabel5ModuleInterop: _commander2.default.enableLegacyBabel5ModuleInterop,
    },
  };

  buildDirectory(options).catch((e) => {
    process.exitCode = 1;
    console.error(e);
  });
} exports.default = run;






async function findFiles(options) {
  const outDirPath = options.outDirPath;
  const srcDirPath = options.srcDirPath;

  const extensions = options.sucraseOptions.transforms.includes("typescript")
    ? [".ts", ".tsx"]
    : [".js", ".jsx"];

  if (!(await _fs.exists.call(void 0, outDirPath))) {
    await _fs.mkdir.call(void 0, outDirPath);
  }

  const outArr = [];
  for (const child of await _fs.readdir.call(void 0, srcDirPath)) {
    if (["node_modules", ".git"].includes(child) || options.excludeDirs.includes(child)) {
      continue;
    }
    const srcChildPath = _path.join.call(void 0, srcDirPath, child);
    const outChildPath = _path.join.call(void 0, outDirPath, child);
    if ((await _fs.stat.call(void 0, srcChildPath)).isDirectory()) {
      const innerOptions = {...options};
      innerOptions.srcDirPath = srcChildPath;
      innerOptions.outDirPath = outChildPath;
      const innerFiles = await findFiles(innerOptions);
      outArr.push(...innerFiles);
    } else if (extensions.some((ext) => srcChildPath.endsWith(ext))) {
      const outPath = outChildPath.replace(/\.\w+$/, `.${options.outExtension}`);
      outArr.push({
        srcPath: srcChildPath,
        outPath,
      });
    }
  }

  return outArr;
}

async function runGlob(options) {
  const tsConfigPath = _path.join.call(void 0, options.project, "tsconfig.json");

  let str;
  try {
    str = await _fs.readFile.call(void 0, tsConfigPath, "utf8");
  } catch (err) {
    console.error("Could not find project tsconfig.json");
    console.error(`  --project=${options.project}`);
    console.error(err);
    process.exit(1);
  }
  const json = JSON.parse(str);

  const foundFiles = [];

  const files = json.files;
  const include = json.include;

  const absProject = _path.join.call(void 0, process.cwd(), options.project);
  const outDirs = [];

  if (!(await _fs.exists.call(void 0, options.outDirPath))) {
    await _fs.mkdir.call(void 0, options.outDirPath);
  }

  if (files) {
    for (const file of files) {
      if (file.endsWith(".d.ts")) {
        continue;
      }
      if (!file.endsWith(".ts") && !file.endsWith(".js")) {
        continue;
      }

      const srcFile = _path.join.call(void 0, absProject, file);
      const outFile = _path.join.call(void 0, options.outDirPath, file);
      const outPath = outFile.replace(/\.\w+$/, `.${options.outExtension}`);

      const outDir = _path.dirname.call(void 0, outPath);
      if (!outDirs.includes(outDir)) {
        outDirs.push(outDir);
      }

      foundFiles.push({
        srcPath: srcFile,
        outPath,
      });
    }
  }
  if (include) {
    for (const pattern of include) {
      const globFiles = await _glob.glob.call(void 0, _path.join.call(void 0, absProject, pattern));
      for (const file of globFiles) {
        if (!file.endsWith(".ts") && !file.endsWith(".js")) {
          continue;
        }
        if (file.endsWith(".d.ts")) {
          continue;
        }

        const relativeFile = _path.relative.call(void 0, absProject, file);
        const outFile = _path.join.call(void 0, options.outDirPath, relativeFile);
        const outPath = outFile.replace(/\.\w+$/, `.${options.outExtension}`);

        const outDir = _path.dirname.call(void 0, outPath);
        if (!outDirs.includes(outDir)) {
          outDirs.push(outDir);
        }

        foundFiles.push({
          srcPath: file,
          outPath,
        });
      }
    }
  }

  for (const outDirPath of outDirs) {
    if (!(await _fs.exists.call(void 0, outDirPath))) {
      await _fs.mkdir.call(void 0, outDirPath);
    }
  }

  // TODO: read exclude

  return foundFiles;
}

async function updateOptionsFromProject(options) {
  /**
   * Read the project information and assign the following.
   *  - outDirPath
   *  - transform: imports
   *  - transform: typescript
   *  - enableLegacyTypescriptModuleInterop: true/false.
   */

  const tsConfigPath = _path.join.call(void 0, options.project, "tsconfig.json");

  let str;
  try {
    str = await _fs.readFile.call(void 0, tsConfigPath, "utf8");
  } catch (err) {
    console.error("Could not find project tsconfig.json");
    console.error(`  --project=${options.project}`);
    console.error(err);
    process.exit(1);
  }
  const json = JSON.parse(str);
  const sucraseOpts = options.sucraseOptions;
  if (!sucraseOpts.transforms.includes("typescript")) {
    sucraseOpts.transforms.push("typescript");
  }

  const compilerOpts = json.compilerOptions;
  if (compilerOpts.outDir) {
    options.outDirPath = _path.join.call(void 0, process.cwd(), options.project, compilerOpts.outDir);
  }
  if (compilerOpts.esModuleInterop !== true) {
    sucraseOpts.enableLegacyTypeScriptModuleInterop = true;
  }
  if (compilerOpts.module === "commonjs") {
    if (!sucraseOpts.transforms.includes("imports")) {
      sucraseOpts.transforms.push("imports");
    }
  }
}

async function buildDirectory(options) {
  let files;
  if (options.outDirPath && options.srcDirPath) {
    files = await findFiles(options);
  } else if (options.project) {
    await updateOptionsFromProject(options);
    files = await runGlob(options);
  } else {
    console.error("Project or Source directory required.");
    process.exit(1);
  }

  for (const file of files) {
    await buildFile(file.srcPath, file.outPath, options);
  }
}

async function buildFile(srcPath, outPath, options) {
  if (!options.quiet) {
    console.log(`${srcPath} -> ${outPath}`);
  }
  const code = (await _fs.readFile.call(void 0, srcPath)).toString();
  const transformedCode = _index.transform.call(void 0, code, {...options.sucraseOptions, filePath: srcPath}).code;
  await _fs.writeFile.call(void 0, outPath, transformedCode);
}
